/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package fxmonopoly.utils;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.beans.value.WritableValue;
import javafx.scene.Parent;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * Provides a smooth transition animation from the current Stage size, to the size
 * of the specified root node.
 * <p>
 * Provides only a single accessible static method since this method has no need
 * to maintain an internal representation.
 * <p>
 * Class privacy identifier not provided to ensure that only the StageManager can
 * access the method.
 * @author Sam P. Morrissey.
 */
class StageTransition {
    
    /**
     * /**
     * Ensures that the class cannot be instantiated, since it has no reason to 
     * be, as it has no state and only static methods.
     */
    private StageTransition() {}
    
    /**
     * Creates a sequential transition animation that initially fades the currently 
     * active scene, it then proceeds to resize the Stage to accommodate the queued
     * parent node without initialising a new Scene object. 
     * @param root The root node generated by the FXMLLoader, to be transitioned to.
     */
    public static void runTransition(Stage stage, final Parent root) {
        SequentialTransition seq = new SequentialTransition();
        seq.getChildren().add(0, fadeOut(stage));
        seq.getChildren().add(1, stageProportions(stage, root));
        seq.setCycleCount(1);
        seq.playFromStart();
    }
    
    /**
     * Creates a parallel transition to fade all the Nodes within the current Scene. Required
     * to be done on child nodes, otherwise the entire window becomes transparent.
     * @return Returns the parallel fade transition of all child nodes of the current rootnode.
     */
    private static ParallelTransition fadeOut(Stage stage) {
        ParallelTransition fadeNodes = new ParallelTransition();
        stage.getScene().getRoot().getChildrenUnmodifiable().forEach(e -> {
            
            FadeTransition fade = new FadeTransition(Duration.millis(200), e);
            fade.setFromValue(1.0);
            fade.setToValue(0.0);
            fade.setCycleCount(1);
            fadeNodes.getChildren().add(fade);
            
        });
        return fadeNodes;
    }
    
    /**
     * Creates a timeline on which the width and height of the stage are interpolated
     * against the measurements of the root node to be transitioned to. With the
     * difference in size determining the Duration of the detLength() method call.
     * The onFinished event sets the root of the current scene to the input Parent node.
     * @param root The parent node providing the transition to measurements.
     * @return     The interpolated timeline that alters the stage dimensions and updates the Scene root to the target root.
     */
    private static Timeline stageProportions(Stage stage, Parent root) {
        Timeline timeline = new Timeline();
        timeline.getKeyFrames().addAll(
            new KeyFrame(
                    
                    detLength(stage, root),
                    onFinished -> stage.getScene().setRoot(root),
                    new KeyValue(stageWidth(stage), 
                            root.prefWidth(-1),
                            Interpolator.EASE_OUT),
                    new KeyValue(stageHeight(stage), 
                            root.prefHeight(-1),
                            Interpolator.EASE_OUT)
                    
            )
        );
        timeline.setCycleCount(1);
        
        return timeline;
    }
    
    /**
     * Provides limited relative pace scaling based on the absolute difference in size
     * of the axis with the largest disparity.
     * @param root The parent node providing the transition to measurements.
     * @return     The scaled Duration for the stage dimension changes.
     */
    private static Duration detLength(Stage stage, Parent root) {
        
        // -1 in both cases only sets the values to not be determined by the other
        // and is a requisite for retrieving the double value.
        double x = Math.abs(stage.getWidth() - root.prefWidth(-1));
        double y = Math.abs(stage.getHeight() - root.prefHeight(-1));
        double use;
        
        Duration period;
        if(x > y) {
            use = x;
        }
        else {
            use = y;
        }
        
        if(use < 50) {
            period = Duration.millis(150.0);
        }
        else if(use < 150) {
            period = Duration.millis(300.0);
        }
        else if(use < 300) {
            period = Duration.millis(800.0);
        }
        else {
            period = Duration.millis(1600.0);
        }
        return period;
    }
    
    /**
     * A writable value required for the necessary KeyValue calls, based on the
     * width of the Stage. Not provided as standard in the JavaFX API.
     * @return The width of the Stage
     */
    private static WritableValue stageWidth(Stage stage) {
        WritableValue<Double> width = new WritableValue<Double>() {
            
            @Override
            public Double getValue() {
                return stage.getWidth();
            }

            @Override
            public void setValue(Double value) {
                stage.setWidth(value);
            }
        };
        return width;
        
    }
    
    /** 
     * A writable value required for the necessary KeyValue calls, based on the
     * height of the Stage. Not provided as standard in the JavaFX API.
     * @return The height of the Stage
     */
    private static WritableValue stageHeight(Stage stage) {
        WritableValue<Double> height = new WritableValue<Double>() {
            
            @Override
            public Double getValue() {
                return stage.getHeight();
            }

            @Override
            public void setValue(Double value) {
                stage.setHeight(value);
            }
        };
        return height;
    }
}
