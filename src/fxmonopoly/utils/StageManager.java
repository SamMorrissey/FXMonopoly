/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package fxmonopoly.utils;

import fxmonopoly.utils.interfacing.Manageable;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Modality;
import javafx.util.Duration;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.FadeTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.beans.value.WritableValue;
import java.io.IOException;


/**
 * Initialises the singleton Stage of the entire application, whilst dealing with
 * any transitions between different Scenes in the application, including a transitional
 * animation. Requires a View enum value to specify the scene to transition to.
 * <p>
 * Also provides a way of displaying non-Dynamic Dialogs that are utilised 
 * throughout the program from one location, as well as provide a way to get the base
 * of dynamic dialogs which can have their content modified. Primarily done to avoid the 
 * Stage being utilised in external classes, since via the aforementioned method, this
 * class will pass the Stage variable needed for dialog ownership.
 * @author Sam P. Morrissey
 */
public class StageManager {
    // The single constant stage to be utilised by the manager
    private final Stage stage;
    
    private FXMLLoader loader;
    
    private double xOffset;
    private double yOffset;
    
    // For resuming a game in progress, only set upon the start of a game, returned
    // to null upon a game being completed.
    private Scene gameScene;
    
    public StageManager(Stage stage) {
        this.stage = stage;
        initialDisplay();
    }
    
    /*
    public Stage getStage() {
        return stage;
    }
    */
    
    /**
     * Retrieves the specified dialog attached to the input enum value
     * @param dialog The specified dialog
     */
    public void getDialog(Dialogs dialog) {
        dialog.display(stage);
    }
    
    /**
     * Causes the stage to close, thereby exiting the program. Exactly equivalent
     * to a stage.close() call.
     */
    public void exitProgram() {
        stage.close();
    }
    
    /**
     * Gets the content necessary to display the initial scene of the program,
     * and initialises all necessary variables. Also does some initial stage styling,
     * such as setting the initStyle, Icon and Title. 
     * <p>
     * It then calls enablePositionChange to activate click and drag window movement.
     * Finally sets this StageManager instance as the StageManager for the initialised
     * scene.
     */
    private void initialDisplay() {
        //Create and "initialise" used elements to null, for later assignment to actual values
        Parent root;
        loader = null;
        Scene scene = null;
        
        try {
            loader = new FXMLLoader();
            loader.setLocation(getClass().getClassLoader().getResource("fxmonopoly/mainmenu/MainMenuLayout.fxml"));
            root = loader.load();
            scene = new Scene(root);
        }
        catch (IOException e) {
            errorDialog("There was an I/O problem.", e);
        }
        
        // Sets the initial stage parameters
        stage.initStyle(StageStyle.TRANSPARENT);
        stage.getIcons().add(new Image("fxmonopoly/resources/images/Icon.png"));
        stage.setTitle("FXMonopoly");
        stage.setScene(scene);
        stage.show();
        
        // Enables stage click and drag movement
        enablePositionChange();
        // Passes this StageManager instance to the Controller of the initialised Parent
        passStageManager();
    }
    
    /**
     * Loads and displays the node hierarchy as generated by the specific .fxml
     * file attached to the View enum utilised.
     * @param view The window to be switched to.
     */
    public void changeScene(final View view) {
        try {
            Parent viewHierarchy = loadHierarchy(view.getFXMLPath());
            runTransition(viewHierarchy);
            passStageManager();
        }
        catch (Exception e) {
            errorDialog("There was a problem", e);
        }
    }
    
     /**
      * Resets the parent file in order to obtain the correct specifications, since
      * no setter method is available for the Parent class.
      * @param fxmlFilePath The local address for the necessary fxml file.
      * @return             The Parent node generated from the fxml file.
      */
    private Parent loadHierarchy(String fxmlFilePath) {
        Parent root = null;
        loader = null;
        
        try {
            loader = new FXMLLoader();
            loader.setLocation(getClass().getClassLoader().getResource(fxmlFilePath));
            root = loader.load();
        }
        catch (IOException e) {
            errorDialog("There was an I/O problem.", e);
        }
        
        return root;
    }
    
    /**
     * The method that passes this instance of the StageManager to the initialised
     * controller of the new scene. Utilises the setStageManager methods present in
     * this application's custom controllers.
     */
    private void passStageManager() {
        /*
        if(loader.getController() instanceof MainMenuController) {
            MainMenuController control = loader.getController();
            control.setStageManager(this);
        }
        else if(loader.getController() instanceof GameInitSettingsController) {
            GameInitSettingsController control = loader.getController();
            control.setStageManager(this);
        }
        else if(loader.getController() instanceof GameController) {
            GameController control = loader.getController();
            control.setStageManager(this);
        }
        else if(loader.getController() instanceof TradeController) {
            TradeController control = loader.getController();
            control.setStageManager(this);
        }
        */ 
        
        if(loader.getController() instanceof Manageable) {
            
            Manageable manage = loader.getController();
            manage.setStageManager(this);
        }
    }
    
    /**
     * Creates a sequential transition animation that initially fades the currently 
     * active scene, it then proceeds to resize the Stage to accommodate the queued
     * parent node without initialising a new Scene object. 
     * @param root The root node generated by the FXMLLoader, to be transitioned to.
     */
    private void runTransition(final Parent root) {
        SequentialTransition seq = new SequentialTransition();
        seq.getChildren().add(0, fadeOut());
        seq.getChildren().add(1, stageProportions(root));
        seq.setCycleCount(1);
        seq.playFromStart();
    }
    
    /**
     * Creates a parallel transition to fade all the Nodes within the current Scene.
     * @return Returns the parallel fade transition of all child nodes of the current rootnode.
     */
    private ParallelTransition fadeOut() {
        ParallelTransition fadeNodes = new ParallelTransition();
        stage.getScene().getRoot().getChildrenUnmodifiable().forEach(e -> {
            
            FadeTransition fade = new FadeTransition(Duration.millis(200), e);
            fade.setFromValue(1.0);
            fade.setToValue(0.0);
            fade.setCycleCount(1);
            fadeNodes.getChildren().add(fade);
            
        });
        return fadeNodes;
    }
    
    /**
     * Creates a timeline on which the width and height of the stage are interpolated
     * against the measurements of the root node to be transitioned to. With the
     * difference in size determining the Duration of the detLength() method call.
     * The onFinished event sets the root of the current scene to the input Parent node.
     * @param root The parent node providing the transition to measurements.
     * @return     The interpolated timeline that alters the stage dimensions and updates the Scene root to the target root.
     */
    private Timeline stageProportions(Parent root) {
        Timeline timeline = new Timeline();
        timeline.getKeyFrames().addAll(
            new KeyFrame(
                    
                    detLength(root),
                    onFinished -> stage.getScene().setRoot(root),
                    new KeyValue(stageWidth(), 
                            root.prefWidth(-1),
                            Interpolator.EASE_OUT),
                    new KeyValue(stageHeight(), 
                            root.prefHeight(-1),
                            Interpolator.EASE_OUT)
                    
            )
        );
        timeline.setCycleCount(1);
        
        return timeline;
    }
    
    /**
     * Provides limited relative pace scaling based on the absolute difference in size
     * of the axis with the largest disparity.
     * @param root The parent node providing the transition to measurements.
     * @return     The scaled Duration for the stage dimension changes.
     */
    private Duration detLength(Parent root) {
        
        // -1 in both cases only sets the values to not be determined by the other
        // and is a requisite for retrieving the double value.
        double x = Math.abs(stage.getWidth() - root.prefWidth(-1));
        double y = Math.abs(stage.getHeight() - root.prefHeight(-1));
        double use;
        
        Duration period;
        if(x > y) {
            use = x;
        }
        else {
            use = y;
        }
        
        if(use < 50) {
            period = Duration.millis(150.0);
        }
        else if(use < 150) {
            period = Duration.millis(300.0);
        }
        else if(use < 300) {
            period = Duration.millis(800.0);
        }
        else {
            period = Duration.millis(1600.0);
        }
        return period;
    }
    
    /**
     * A writable value required for the necessary KeyValue calls, based on the
     * width of the Stage. Not provided as standard in the JavaFX API.
     * @return The width of the Stage
     */
    private WritableValue stageWidth() {
        WritableValue<Double> width = new WritableValue<Double>() {
            
            @Override
            public Double getValue() {
                return stage.getWidth();
            }

            @Override
            public void setValue(Double value) {
                stage.setWidth(value);
            }
        };
        return width;
        
    }
    
    /** 
     * A writable value required for the necessary KeyValue calls, based on the
     * height of the Stage. Not provided as standard in the JavaFX API.
     * @return The height of the Stage
     */
    private WritableValue stageHeight() {
        WritableValue<Double> height = new WritableValue<Double>() {
            
            @Override
            public Double getValue() {
                return stage.getHeight();
            }

            @Override
            public void setValue(Double value) {
                stage.setHeight(value);
            }
        };
        return height;
    }
    
    /**
     * Creates a dialog displaying the exception information.
     * @param message The message to be displayed
     * @param exception The exception causing the dialog
     */
    private void errorDialog(String message, Exception exception) {
        Alert aboutAlert = new Alert(Alert.AlertType.NONE);
        aboutAlert.initStyle(StageStyle.TRANSPARENT);
        
        // Synchronises the dialog with the maine menu styling css file
        aboutAlert.getDialogPane().getStylesheets().add(getClass().getClassLoader().getResource("fxmonopoly/mainmenu/MainMenuStyle.css").toExternalForm());
        aboutAlert.getDialogPane().getStyleClass().add("dialog-pane");
        
        // Allows the Dialogs to track the position of the currently open window
        aboutAlert.initModality(Modality.APPLICATION_MODAL);
        aboutAlert.initOwner(stage);
        
        // Sets the content of the Dialogs and displays it
        aboutAlert.setContentText(message + "\n"
                                 +exception.getCause()
                                 );
        aboutAlert.getButtonTypes().add(ButtonType.OK);
        aboutAlert.showAndWait();
        stage.close();
    }
    
    /**
     * Enables the window to be repositioned via clicking and dragging on 
     * the root node and other non-focusable nodes such as ImageViews. Required
     * since the default style of the Stage is set to transparent and cannot be
     * repositioned otherwise. 
     * <p>
     * Only requires a single call, as long as scene still refers to the same
     * initial scene generated (since currently the Root of the Scene is altered
     * instead of switching the Scene itself). Otherwise this must be called again.
     */
    private void enablePositionChange() {
        Scene scene = stage.getScene();
        
        scene.setOnMousePressed(e -> {
            xOffset = stage.getX() - e.getScreenX();
            yOffset = stage.getY() - e.getScreenY();
        });
        
        scene.setOnMouseDragged(e -> {
            stage.setX(e.getScreenX() + xOffset);
            stage.setY(e.getScreenY() + yOffset);
        });
    }
}
