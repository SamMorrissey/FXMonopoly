/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package fxmonopoly.utils;

import javafx.stage.Stage;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import java.io.IOException;
import java.util.Objects;
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.stage.Modality;
/**
 *
 * @author Sam P. Morrissey
 */
public class StageManager {
    // The constant elements to be utilised by the manager
    private final Stage stage;
    private final FXMLLoader loader;
    
    // For resuming a game in progress, only set upon the start of a game, returned
    // to null upon a game being completed.
    private Scene gameScene;
    
    public StageManager(Stage stage, FXMLLoader loader) {
        this.stage = stage;
        this.loader = loader;
    }
    
    /*
     * Loads and displays the node hierarchy as generated by the specific .fxml
     * file attached to the View enum utilised.
     * @param view The window to be switched to
     */
    public void changeScene(final View view) {
        Parent viewHierarchy = loadHierarchy(view.getFXMLPath());
        display(viewHierarchy);
    }
    
    /*
     * Calls the setupScene method to generate the scene specified by the .fxml
     * file, as well as taking the necessary steps to display the scene as the
     * active window.
     * @param root The parent .fxml file containing the necessary information
     */
    public void display(final Parent root) {
        Scene scene = setupScene(root);
        
        stage.setScene(scene);
        stage.sizeToScene();
        stage.centerOnScreen();
        stage.show();
    }
    
    /*
     * Utilises the .fxml parameters specified to update the current scene or
     * create a new scene if the scene is null (not possible with current implementation).
     * @param root The parent .fxml file containing the necessary information
     */
    public Scene setupScene(Parent root) {
        Scene scene = stage.getScene();
        
        if(scene == null) {
            scene = new Scene(root);
        }
        scene.setRoot(root);
        return scene;
    }
    
    /*
     * Resets the parent file in order to obtain the correct specifications, since
     * no setter method is available for the Parent class.
     * @param fxmlFilePath The local address for the necessary .fxml file
     */
    private Parent loadHierarchy(String fxmlFilePath) {
        Parent root = null;
        try {
            root = FXMLLoader.load(getClass().getResource(fxmlFilePath));
            Objects.requireNonNull(root, "Root FXML cannot be null");
        }
        catch (IOException e) {
            errorDialog("There was an I/O problem.", e);
        }
        return root;
    }
    
    /*
     * Creates a dialog displaying the exception information.
     * @param message The message to be displayed
     * @param exception The exception causing the dialog
    */
    public void errorDialog(String message, Exception exception) {
        Alert aboutAlert = new Alert(Alert.AlertType.NONE);
        aboutAlert.initStyle(StageStyle.TRANSPARENT);
        
        // Synchronises the dialog with the maine menu styling css file
        aboutAlert.getDialogPane().getStylesheets().add(getClass().getResource("/mainmenu/MainMenuStyle.css").toExternalForm());
        aboutAlert.getDialogPane().getStyleClass().add("dialog-pane");
        
        // Allows the Dialog to track the position of the currently open window
        aboutAlert.initModality(Modality.APPLICATION_MODAL);
        aboutAlert.initOwner(stage);
        
        // Sets the content of the Dialog and displays it
        aboutAlert.setContentText(message + "\n"
                                 +exception.getCause()
                                 );
        aboutAlert.getButtonTypes().add(ButtonType.OK);
        aboutAlert.showAndWait();
        stage.close();
    }
}
