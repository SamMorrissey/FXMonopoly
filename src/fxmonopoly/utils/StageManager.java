/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package fxmonopoly.utils;

import fxmonopoly.game.GameController;
import fxmonopoly.gameinitsettings.GameInitSettingsController;
import fxmonopoly.mainmenu.MainMenuController;
import fxmonopoly.trade.TradeController;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Modality;
import java.io.IOException;
import java.util.Objects;
import javafx.util.Duration;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.FadeTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.beans.value.WritableValue;


/**
 *
 * @author Sam P. Morrissey
 */
public class StageManager {
    // The constant elements to be utilised by the manager
    private final Stage stage;
    private FXMLLoader loader;
    
    private double xOffset;
    private double yOffset;
    
    // For resuming a game in progress, only set upon the start of a game, returned
    // to null upon a game being completed.
    private Scene gameScene;
    
    public StageManager(Stage stage, FXMLLoader loader) {
        this.stage = stage;
        this.loader = loader;
        enablePositionChange();
    }
    
    public Stage getStage() {
        return stage;
    }
    
    public void getDialog(Dialogs dialog) {
        dialog.display(stage);
    }
    
    /*
     * Loads and displays the node hierarchy as generated by the specific .fxml
     * file attached to the View enum utilised.
     * @param view The window to be switched to
     */
    public void changeScene(final View view) {
        try {
            Parent viewHierarchy = loadHierarchy(view.getFXMLPath());
            runTransition(viewHierarchy);
            passStageManager();
        }
        catch (Exception e) {
            errorDialog("There was a problem", e);
        }
    }
    
     /**
      * Resets the parent file in order to obtain the correct specifications, since
      * no setter method is available for the Parent class.
      * @param fxmlFilePath The local address for the necessary fxml file
      * @return             The Parent node generated from the fxml file
      */
    private Parent loadHierarchy(String fxmlFilePath) {
        Parent root = null;
        loader = null;
        try {
            loader = new FXMLLoader();
            loader.setLocation(getClass().getClassLoader().getResource(fxmlFilePath));
            root = loader.load();
            Objects.requireNonNull(root, "Root FXML cannot be null");
        }
        catch (IOException e) {
            errorDialog("There was an I/O problem.", e);
        }
        
        return root;
    }
    
    /**
     * The method that passes this instance of the StageManager to the initialised
     * controller of the new scene. Utilises the setStageManager methods present in
     * this application's custom controllers.
     */
    private void passStageManager() {
        if(loader.getController() instanceof MainMenuController) {
            MainMenuController control = loader.getController();
            control.setStageManager(this);
        }
        else if(loader.getController() instanceof GameInitSettingsController) {
            GameInitSettingsController control = loader.getController();
            control.setStageManager(this);
        }
        else if(loader.getController() instanceof GameController) {
            GameController control = loader.getController();
            control.setStageManager(this);
        }
        else if(loader.getController() instanceof TradeController) {
            TradeController control = loader.getController();
            control.setStageManager(this);
        }
    }
    
    /**
     * Creates a sequential transition animation that initially fades the currently 
     * active scene, it then proceeds to resize the Stage to accommodate the queued
     * parent node without initialising a new Scene object. The onFinished event sets
     * the root of the current scene to the input Node and calls enablePositionChange
     * which is reset after animations. 
     * @param root The root node generated by the FXMLLoader, to be transitioned to.
     */
    private void runTransition(final Parent root) {
        SequentialTransition seq = new SequentialTransition();
        seq.getChildren().add(0, fadeOut());
        seq.getChildren().add(1, stageProportions(root));
        seq.setCycleCount(1);
        seq.playFromStart();
    }
    
    /**
     * Creates a parallel transition to fade all the Nodes within the current Scene.
     * @return Returns the parallel fade transition of all child nodes of the current rootnode.
     */
    private ParallelTransition fadeOut() {
        ParallelTransition fadeNodes = new ParallelTransition();
        stage.getScene().getRoot().getChildrenUnmodifiable().forEach(e -> {
            FadeTransition fade = new FadeTransition(Duration.millis(200), e);
            fade.setFromValue(1.0);
            fade.setToValue(0.0);
            fade.setCycleCount(1);
            fadeNodes.getChildren().add(fade);
        });
        return fadeNodes;
    }
    
    /**
     * Creates a timeline on which the width and height of the stage are interpolated
     * against the measurements of the root node to be transitioned to. With the
     * difference in size determining the Duration of the detLength() method call.
     * @param root The parent node providing the transition to measurements
     * @return     The interpolated timeline that alters the stage dimensions and updates the Scene root to the target root.
     */
    private Timeline stageProportions(Parent root) {
        Timeline timeline = new Timeline();
        timeline.getKeyFrames().addAll(
            new KeyFrame(
                detLength(root),
                onFinished -> stage.getScene().setRoot(root),
                new KeyValue(stageWidth(), 
                        root.prefWidth(-1),
                        Interpolator.EASE_OUT),
                new KeyValue(stageHeight(), 
                        root.prefHeight(-1),
                        Interpolator.EASE_OUT)
            )
        );
        timeline.setCycleCount(1);
        
        return timeline;
    }
    
    /**
     * Provides limited relative pace scaling based on the absolute difference in size
     * of the axis with the largest disparity.
     * @param root The parent node providing the transition to measurements
     * @return     The scaled Duration for the stage dimension changes
     */
    private Duration detLength(Parent root) {
        
        // -1 in both cases only sets the values to not be determined by the other
        // and is a requisite for retrieving the double value.
        double x = Math.abs(stage.getWidth() - root.prefWidth(-1));
        double y = Math.abs(stage.getHeight() - root.prefHeight(-1));
        double use;
        
        Duration period;
        if(x > y) {
            use = x;
        }
        else {
            use = y;
        }
        
        if(use < 50) {
            period = Duration.millis(150.0);
        }
        else if(use < 150) {
            period = Duration.millis(300.0);
        }
        else if(use < 300) {
            period = Duration.millis(600.0);
        }
        else {
            period = Duration.millis(800.0);
        }
        return period;
    }
    
    /**
     * A writable value required for the necessary KeyValue calls, based on the
     * width of the Stage. Not provided as standard in the JavaFX API.
     * @return The width of the Stage
     */
    private WritableValue stageWidth() {
        WritableValue<Double> width = new WritableValue<Double>() {
        @Override
        public Double getValue() {
            return stage.getWidth();
        }

        @Override
        public void setValue(Double value) {
            stage.setWidth(value);
        }
        };
        return width;
    }
    
    /** 
     * A writable value required for the necessary KeyValue calls, based on the
     * height of the Stage. Not provided as standard in the JavaFX API.
     * @return The height of the Stage
     */
    private WritableValue stageHeight() {
        WritableValue<Double> height = new WritableValue<Double>() {
        @Override
        public Double getValue() {
            return stage.getHeight();
        }

        @Override
        public void setValue(Double value) {
            stage.setHeight(value);
        }
        };
        return height;
    }
    
    /**
     * Creates a dialog displaying the exception information.
     * @param message The message to be displayed
     * @param exception The exception causing the dialog
     */
    private void errorDialog(String message, Exception exception) {
        Alert aboutAlert = new Alert(Alert.AlertType.NONE);
        aboutAlert.initStyle(StageStyle.TRANSPARENT);
        
        // Synchronises the dialog with the maine menu styling css file
        aboutAlert.getDialogPane().getStylesheets().add(getClass().getClassLoader().getResource("fxmonopoly/mainmenu/MainMenuStyle.css").toExternalForm());
        aboutAlert.getDialogPane().getStyleClass().add("dialog-pane");
        
        // Allows the Dialogs to track the position of the currently open window
        aboutAlert.initModality(Modality.APPLICATION_MODAL);
        aboutAlert.initOwner(stage);
        
        // Sets the content of the Dialogs and displays it
        aboutAlert.setContentText(message + "\n"
                                 +exception.getCause()
                                 );
        aboutAlert.getButtonTypes().add(ButtonType.OK);
        aboutAlert.showAndWait();
        stage.close();
    }
    
    /**
     * Enables the window to be repositioned via clicking and dragging on 
     * the root node and other non-focusable nodes such as ImageViews. Required
     * since the default style of the Stage is set to transparent and cannot be
     * repositioned otherwise.
     */
    private void enablePositionChange() {
        Scene scene = stage.getScene();
        
        scene.setOnMousePressed(e -> {
            xOffset = stage.getX() - e.getScreenX();
            yOffset = stage.getY() - e.getScreenY();
        });
        
        scene.setOnMouseDragged(e -> {
            stage.setX(e.getScreenX() + xOffset);
            stage.setY(e.getScreenY() + yOffset);
        });
    }
}
